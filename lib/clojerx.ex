defmodule Clojerx do
  @moduledoc """
  Documentation for `Clojerx`.
  """

  defmacro __using__(opts) do
    otp_app = Keyword.fetch!(opts, :otp_app)
    module = __CALLER__.module |> Module.split() |> List.last()
    clj_dir = Path.join(Path.dirname(__CALLER__.file), module)
    clj_ns = module
    erl_jar = Clojerx.ensure_jinterface_jar()
    output_jar = Clojerx.ensure_jar_path(otp_app, clj_ns)
    Clojerx.ensure_clojure_project(clj_dir, clj_ns)
    Clojerx.create_jar(clj_dir, clj_ns, erl_jar, output_jar)

    quote do
      use GenServer

      def start_link(opts \\ []) do
        GenServer.start_link(__MODULE__, opts)
      end

      def call(srv, :sum, args) do
        GenServer.call(srv, {:sum, args})
      end

      @impl true
      def init(_opts) do
        port = execute_clojure(unquote(clj_dir), unquote(clj_ns), unquote(erl_jar))
        Port.monitor(port)

        case wait_for_node(clojerx_node(), 1000) do
          {:error, :timeout} ->
            raise "Node not available #{clojerx_node()}"

          _ ->
            :ok
        end

        send(clojerx_dest(), {:clojerx, make_ref(), self(), :link, {}})

        {:ok,
         %{
           clojure_port: port,
           clojerx_node: clojerx_node(),
           clojerx_dest: clojerx_dest(),
           clojerx_jar: unquote(output_jar)
         }}
      end

      defp clojerx_dest do
        {:"#{unquote(clj_ns)}", clojerx_node()}
      end

      defp clojerx_node do
        [_name, domain] = Node.self() |> to_string() |> String.split("@", parts: 2)
        :"#{unquote(clj_ns)}@#{domain}"
      end

      defp execute_clojure(clj_dir, clj_ns, erl_jar) do
        java_path = System.find_executable("java")

        Port.open(
          {:spawn_executable, java_path},
          [
            :nouse_stdio,
            :binary,
            cd: clj_dir,
            args: ["-jar", unquote(output_jar)]
          ]
        )
      end

      defp wait_for_node(_node_name, timeout) when timeout <= 0, do: {:error, :timeout}

      defp wait_for_node(node_name, timeout) do
        case Node.ping(node_name) do
          :pong ->
            :ok

          _ ->
            Process.sleep(100)
            wait_for_node(node_name, timeout - 100)
        end
      end

      @impl true
      def handle_call({:sum, [a, b]}, from, state) do
        send(state.clojerx_dest, {:clojerx, from, self(), :sum, {a, b}})
        {:noreply, state}
      end

      @impl true
      def handle_info({_, {:data, out}}, state) do
        IO.inspect(out)
        {:noreply, state}
      end

      @impl true
      def handle_info({:clojerx, _ref, :link}, state) do
        {:noreply, state}
      end

      def handle_info({:clojerx, from, :sum, result}, state) do
        GenServer.reply(from, result)
        {:noreply, state}
      end

      def handle_info({:DOWN, _, :port, _, reason}, state) do
        IO.inspect(reason)
        {:stop, reason, state}
      end

      @impl true
      def terminate(_reason, %{clojure_port: port}) do
        Port.close(port)
        :ok
      end
    end
  end

  def ensure_clojure_project(clj_dir, clj_ns) do
    main_src = Path.join(clj_dir, "src")

    if not File.exists?(Path.join(main_src, "#{clj_ns}.clj")) do
      raise "Clojure source file not found at #{main_src}/#{clj_ns}.clj"
    end
  end

  def ensure_jinterface_jar() do
    erl_jar = Path.join(:code.priv_dir(:clojerx), "OtpErlang-26.jar")

    if not File.exists?(erl_jar) do
      raise "Erlang JInterface jar not found at #{erl_jar}"
    end

    erl_jar
  end

  defp ensure_deps_edns(clj_dir) do
    deps = ~s(
    ; AUTOMATICALLY GENERATED BY CLOJERX DO NOT EDIT
    {:paths ["src"]
      :deps {org.clojure/clojure {:mvn/version "1.12.4"}}
      :aliases
      {:build {:deps {io.github.clojure/tools.build {:git/tag "v0.10.11" :git/sha "c6c670a"}}
               :ns-default build}}
    }
    )
    File.write!(Path.join(clj_dir, "deps.edn"), deps)
  end

  defp ensure_build_clj(clj_dir, clj_ns, erl_jar, output_jar) do
    build_clj = ~s|
    ; AUTOMATICALLY GENERATED BY CLOJERX DO NOT EDIT
    (ns build
      (:require [clojure.tools.build.api :as b]))

    (def class-dir "target/classes")
    (def uber-file "#{output_jar}")

    ;; delay to defer side effects (artifact downloads)
    (def basis (delay (b/create-basis {:project "deps.edn" :extra {
    :deps {'otp-erlang/OtpErlang {:local/root "#{erl_jar}"}}
    }})))

    (defn clean [_]
      (b/delete {:path "target"}))

    (defn uber [_]
      (clean nil)
      (b/copy-dir {:src-dirs ["src" "resources"]
                   :target-dir class-dir})
      (b/compile-clj {:basis @basis
                      :ns-compile '[#{clj_ns}]
                      :class-dir class-dir})
      (b/uber {:class-dir class-dir
               :uber-file uber-file
               :basis @basis
               :main '#{clj_ns}}))
|
    File.write!(Path.join(clj_dir, "build.clj"), build_clj)
  end

  def create_jar(clj_dir, clj_ns, erl_jar, output_jar) do
    clojure_path = System.find_executable("clojure")

    ensure_build_clj(clj_dir, clj_ns, erl_jar, output_jar)
    ensure_deps_edns(clj_dir)

    System.cmd(clojure_path, ["-T:build", "uber"], cd: clj_dir)
  end

  def ensure_jar_path(otp_app, clj_ns) do
    jar_dir =
      otp_app
      |> :code.lib_dir()
      |> Path.join("priv")

    File.mkdir_p!(jar_dir)

    Path.join(jar_dir, "#{clj_ns}.jar")
  end
end
