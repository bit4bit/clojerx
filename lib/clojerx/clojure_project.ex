defmodule Clojerx.ClojureProject do
  @moduledoc false

  use PrivateModule

  def project_sources(clj_dir) do
    Path.wildcard(Path.join(clj_dir, "src/**/*.clj"))
    ++ [Path.join(clj_dir, "build.clj")]
  end

  def ensure_clojure_project(clj_dir, clj_ns) do
    main_src = Path.join(clj_dir, "src")

    if not File.exists?(Path.join(main_src, "#{clj_ns}.clj")) do
      raise "Clojure source file not found at #{main_src}/#{clj_ns}.clj"
    end
  end

  def ensure_jar_path(otp_app, clj_ns) do
    jar_dir =
      otp_app
      |> :code.lib_dir()
      |> Path.join("priv")

    File.mkdir_p!(jar_dir)

    Path.join(jar_dir, "#{clj_ns}.jar")
  end

  def ensure_deps_edns(clj_dir, extra_deps_edn) do
    formatted_deps_edn =
      Enum.map(extra_deps_edn, fn
        clojerx_module when is_atom(clojerx_module) ->
          clojerx_info = clojerx_module.__clojerx__()
          clj_ns = clojerx_info[:clj_ns]
          {"#{clj_ns}/#{clj_ns}", :"local/root", clojerx_info[:output_jar]}

        {name, {source, version}} ->
          {name, source, version}
      end)
      |> Enum.map(fn {name, source, version} ->
        ~s(#{name} {:#{source} "#{version}"})
      end)

    deps = ~s(
    ; AUTOMATICALLY GENERATED BY CLOJERX DO NOT EDIT
    {:paths ["src"]
      :deps {org.clojure/clojure {:mvn/version "1.12.4"} #{formatted_deps_edn}}
      :aliases
      {:build {:deps {io.github.clojure/tools.build {:git/tag "v0.10.11" :git/sha "c6c670a"}} #{formatted_deps_edn}
               :ns-default build}}
    }
    )
    File.write!(Path.join(clj_dir, "deps.edn"), deps)
  end

  def ensure_build_clj(clj_dir, clj_ns, erl_jar, output_jar) do
    build_clj = ~s|
    ; AUTOMATICALLY GENERATED BY CLOJERX DO NOT EDIT
    (ns build
      (:require [clojure.tools.build.api :as b]))

    (def class-dir "target/classes")
    (def uber-file "#{output_jar}")

    ;; delay to defer side effects (artifact downloads)
    (def basis (delay (b/create-basis {:project "deps.edn" :extra {
    :deps {'otp-erlang/OtpErlang {:local/root "#{erl_jar}"}}
    }})))

    (defn clean [_]
      (b/delete {:path "target"}))

    (defn uber [_]
      (clean nil)
      (b/copy-dir {:src-dirs ["src" "resources"]
                   :target-dir class-dir})
      (b/compile-clj {:basis @basis
                      :ns-compile '[#{clj_ns}]
                      :class-dir class-dir})
      (b/uber {:class-dir class-dir
               :uber-file uber-file
               :basis @basis
               :main '#{clj_ns}}))
|
    File.write!(Path.join(clj_dir, "build.clj"), build_clj)
  end
end
