defmodule Clojerx.Compiler do
  @moduledoc false

  defmacro __before_compile__(%{module: module}) do
    clj_dir = Module.get_attribute(module, :clojerx_clj_dir)
    clj_ns = Module.get_attribute(module, :clojerx_clj_ns)
    output_jar = Module.get_attribute(module, :clojerx_output_jar)
    erl_jar = Clojerx.Compiler.ensure_jinterface_jar()

    Clojerx.Compiler.ensure_clojure_project(clj_dir, clj_ns)
    Clojerx.Compiler.create_jar(clj_dir, clj_ns, erl_jar, output_jar)

    quote do
    end
  end

  def ensure_clojure_project(clj_dir, clj_ns) do
    main_src = Path.join(clj_dir, "src")

    if not File.exists?(Path.join(main_src, "#{clj_ns}.clj")) do
      raise "Clojure source file not found at #{main_src}/#{clj_ns}.clj"
    end
  end

  def ensure_jinterface_jar() do
    erl_jar = Path.join(:code.priv_dir(:clojerx), "OtpErlang-26.jar")

    if not File.exists?(erl_jar) do
      raise "Erlang JInterface jar not found at #{erl_jar}"
    end

    erl_jar
  end

  defp ensure_deps_edns(clj_dir) do
    deps = ~s(
    ; AUTOMATICALLY GENERATED BY CLOJERX DO NOT EDIT
    {:paths ["src"]
      :deps {org.clojure/clojure {:mvn/version "1.12.4"}}
      :aliases
      {:build {:deps {io.github.clojure/tools.build {:git/tag "v0.10.11" :git/sha "c6c670a"}}
               :ns-default build}}
    }
    )
    File.write!(Path.join(clj_dir, "deps.edn"), deps)
  end

  defp ensure_build_clj(clj_dir, clj_ns, erl_jar, output_jar) do
    build_clj = ~s|
    ; AUTOMATICALLY GENERATED BY CLOJERX DO NOT EDIT
    (ns build
      (:require [clojure.tools.build.api :as b]))

    (def class-dir "target/classes")
    (def uber-file "#{output_jar}")

    ;; delay to defer side effects (artifact downloads)
    (def basis (delay (b/create-basis {:project "deps.edn" :extra {
    :deps {'otp-erlang/OtpErlang {:local/root "#{erl_jar}"}}
    }})))

    (defn clean [_]
      (b/delete {:path "target"}))

    (defn uber [_]
      (clean nil)
      (b/copy-dir {:src-dirs ["src" "resources"]
                   :target-dir class-dir})
      (b/compile-clj {:basis @basis
                      :ns-compile '[#{clj_ns}]
                      :class-dir class-dir})
      (b/uber {:class-dir class-dir
               :uber-file uber-file
               :basis @basis
               :main '#{clj_ns}}))
|
    File.write!(Path.join(clj_dir, "build.clj"), build_clj)
  end

  def create_jar(clj_dir, clj_ns, erl_jar, output_jar) do
    clojure_path = System.find_executable("clojure")

    if is_nil(clojure_path) do
      raise "Clojure executable not found"
    end

    ensure_build_clj(clj_dir, clj_ns, erl_jar, output_jar)
    ensure_deps_edns(clj_dir)

    System.cmd(clojure_path, ["-T:build", "uber"], cd: clj_dir)
  end
end
